
<script src="/assets/js/list.min.js"></script>

<div id="main" class="alt">
  <section>
    <div class="inner">
      <header class="major">
        <h2>Papers</h2>
      </header>
      <div id="paper-list">
        {% assign categories = "Overview| Deception| Forecasting| AI Governance| Alignment <-> RLHF| Scalable oversight| Capabilities of LLMs| Research bottlenecks / limitations| Adversaries / Robustness / Generalization| Model evaluations / monitoring / detection| Reward misspecification and goal misgeneralization| Major problems (misalignment, misuse, threat models)| Transparency / Interpretability / Model internals / Latent knowledge" | split: "| " %}
        {% assign topics = "Debate| Trojans| Security| Sycophancy| Uncertainty| Benchmarking| Model editing| Compute governance| Automated interpretability| Mechanistic interpretability| Detection of out-of-distribution or malicious behavior| Situational awareness (also instrumental convergence, inner misalignment)" | split: "| " %}
        {% assign ml_domain_tags = "NLP| Vision| Theory| Security| Applied ML| Optimization| Domain General| Model Evaluation| Reinforcement Learning| Human Model Interaction| Robustness and Adversariality| Probabilistic Modeling and Bayesian ML" | split: "| " %}
        {% assign ml_domain_tags_fine_grain = "NLP: LLMs| RL: Games| RL: Simulations| NLP: Summarization| Applied ML: Chatbots| Applied ML: Robotics| NLP: Language Modeling| NLP: Question Answering| Applied ML: Cognitive Tasks| Applied ML: Autonomous Vehicles| Applied ML: AI-Based Automation| Applied ML: Medicine and Health| Applied ML: Efficiency and Hardware" | split: "| " %}
        {% assign empty = "" | split: "|" %}

        <div class="row mt1 mb1">
          <div class="12u">
            <input type="search" class="search form-control" placeholder="Search" />
          </div>
        </div>
        <div class="row">
          {% include paper_filter.html field_id="category" field_display="Category" options=empty %}
          {% include paper_filter.html field_id="topic" field_display="Topic" options=empty %}
          {% include paper_filter.html field_id="ml_domain_tag" field_display="ML Domain Tag" options=empty %}
          {% include paper_filter.html field_id="ml_domain_tag_fine-grain" field_display="ML Domain Tag Fine-Grain" options=empty %}
          <div class="filter-list"></div>
        </div>
        <div class="results-count">
          <span class="results-count-text"><span class="results-count-number">0</span> results</span>
        </div>
        <ul class="list"></ul>
      </div>
    </div>
  </section>
</div>

<div class="hidden">
  <li id="paper-item" class="paper-item">
    <div class="title-container">
      <img class="medium-icon image" />
      <h3 class="Title"></h3>
    </div>
    <div class="detail-opener">
      <svg aria-label="open" aria-hidden="true" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
      </svg>
    </div>
    <div class="detail">
      <div class="CategoryDisplay"></div>
      <div class="ML Domain TagDisplay"></div>
      <div class="ML Domain Tag Fine-GrainDisplay"></div>
      <div class="TopicDisplay"></div>
      <div class="TwitterDisplay"></div>
      <div class="Blog or VideoDisplay"></div>
      <div class="Supplementary MaterialDisplay"></div>
      <div class="Transcripts / Audio / SlidesDisplay"></div>
      <div class="AbstractDisplay"></div>
    </div>
  </li>
</div>

<script>
  var papersList;
  const filters = {
    Category: new Set(),
    Topic: new Set(),
    "ML Domain Tag": new Set(),
    "ML Domain Tag Fine-Grain": new Set(),
  }
  const filterOptions = {
    Category: new Set(),
    Topic: new Set(),
    "ML Domain Tag": new Set(),
    "ML Domain Tag Fine-Grain": new Set(),
  }

  const options = {
    valueNames: [
      'Title',
      'TopicDisplay',
      'Category',
      'CategoryDisplay',
      'Medium',
      'Twitter',
      'TwitterDisplay',
      "Blog or Video",
      "Blog or VideoDisplay",
      "Supplementary Material",
      "Supplementary MaterialDisplay",
      "Transcripts / Audio / Slides",
      "Transcripts / Audio / SlidesDisplay",
      "ML Domain Tag",
      "ML Domain TagDisplay",
      "ML Domain Tag Fine-Grain",
      "ML Domain Tag Fine-GrainDisplay",
      "Abstract",
      "AbstractDisplay",
      { attr: 'src', name: 'image' }
    ],
    item: 'paper-item'
  };

  let papers = [];

  function listify(papersJson) {
    papers = papersJson.map(function(paper) {
      const darkMode =  (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches)
      const modeStr = darkMode ? '-dark' : ''

      if (paper.Medium.length > 1 && paper.Medium.includes("Paper")) {
        paper.image = `/assets/images/medium/paper${modeStr}.svg`;
      } else {
        paper.image = `/assets/images/medium/${paper.Medium[0].toLowerCase()}${modeStr}.svg`;
      }
      paper.CategoryDisplay = paper.Category.map(item => `<span class="field-single category-single">${item}</span>`).join('');
      paper.Topic = paper.Topic ?? [];
      paper.TopicDisplay = paper.Topic.map(item => `<span class="field-single topic-single">${item}</span>`).join('');
      paper['ML Domain TagDisplay'] = paper['ML Domain Tag'].map(tag => `<span class="field-single ml-domain-tag-single">${tag}</span>`).join('');
      paper['ML Domain Tag Fine-Grain'] = paper['ML Domain Tag (Fine-Grain)'] ?? [];
      paper['ML Domain Tag Fine-GrainDisplay'] = paper['ML Domain Tag Fine-Grain'].map(tag => `<span class="field-single ml-domain-fine-grain-tag-single">${tag}</span>`).join('');
      paper.Title = linkify(paper.Link, paper.Title.replace("\n", ''));
      paper['Transcripts / Audio / SlidesDisplay'] = linkify(paper['Transcripts / Audio / Slides'], 'Transcripts / Audio / Slides');
      paper['Supplementary MaterialDisplay'] = linkify(paper['Supplementary Material'], 'Supplementary Material');
      paper['TwitterDisplay'] = linkify(paper['Twitter'], 'Twitter');
      paper['AbstractDisplay'] = paper.Abstract ? `<h4>Abstract</h4>${paper.Abstract}` : '';
      return paper;
    });

    papersList = new List('paper-list', options, papers);

    $(function(){
      $(document).on('change', '.filter-dropdown input', function(e) {
        var filter = this.value;
        var filterType = $(this).closest('.filter-dropdown').data('filter-type');
        if (filters[filterType].has(filter)) {
          filters[filterType].delete(filter);
        } else {
          filters[filterType].add(filter);
        }
        updateList();
      });

      // Get options for each filter from the JSON
      Object.keys(filterOptions).forEach(function(filterType) {
        papers.forEach(function(paper) {
          paper[filterType].forEach(function(filter) {
            filterOptions[filterType].add(filter);
          });
        });
      });

      // Replace the filter options of each ".filter-dropdown ul" with the ones from the JSON
      Object.keys(filterOptions).forEach(function(filterType) {
        var filterDropdown = $('.filter-dropdown-' + slugify(filterType) + ' ul');
        Array.from(filterOptions[filterType]).sort().forEach(function(option) {
          filterDropdown.append(`<li data-option="${option}">
            <input type="checkbox" id="option-${slugify(filterType)}-${option}" name="option-${slugify(filterType)}-${option}" value="${option}">
            <label for="option-${slugify(filterType)}-${option}">
              ${option}
              <span class="filter-option-count"></span>
            </label>
          </li>`);
        });
      });
      
      // On page load, read the query params and set the filters
      var params = new URLSearchParams(window.location.search);
      Object.keys(filters).forEach(function(filterType) {
        if (params.has(filterType)) {
          params.getAll(filterType)[0].split(',').forEach(function(filter) {
            filters[filterType].add(filter);
            $('input[name="option-' + slugify(filterType) + '-' + filter + '"]').prop('checked', true);
          });
        }
      });
      updateList();
    });

    $('input.search').on('change', function(e) {
      updateFilterOptionCounts();
    });

    papersList.on('updated', function (list) {
      updateResultsCount();
    });
  }

  fetch('/export/papers.json')
    .then(response => response.json())
    .then(data => {
      listify(data)
    })
    .catch(error => console.error('Error loading JSON:', error));
  
  function resetList(){
    papersList.search();
    papersList.filter();
    papersList.update();
    $(".filter-all").prop('checked', true);
    $('.filter').prop('checked', false);
    $('.search').val('');
  };

  function updateFilters() {
    papersList.filter(function (paper) {
      return Object.keys(filters).every(function(filterType) {
        if (filters[filterType].size == 0) return true

        return paper.values()[filterType].some(item => filters[filterType].has(item))
      });
    });
  }

  function updateResultsCount(){
    $('.results-count-number').text(papersList.matchingItems.length);
  }

  function updateShownFilters(){
    var filterList = $('.filter-list');
    filterList.empty();
    Object.keys(filters).forEach(function(filterType) {
      filters[filterType].forEach(function(filter) {
        filterList.append(`<span class="filter-item filter-item-${slugify(filterType)}" data-filter-type="${filterType}">` + filter + '</span>');
      });
    });
  }

  function updateFilterTitleCount(){
    Object.keys(filters).forEach(function(filterType) {
      const filterSlug = slugify(filterType)
      if (filters[filterType].size) {
        $('.filter-' + filterSlug + ' .dropdown-title').addClass('filter-active');
        $('.filter-' + filterSlug + ' .dropdown-title .filter-type-count').text('(' + filters[filterType].size + ')');
      } else {
        $('.filter-' + filterSlug + ' .dropdown-title').removeClass('filter-active');
        $('.filter-' + filterSlug + ' .dropdown-title .filter-type-count').text('');
      }
    });
  }

  function updateQueryParams(){
    var params = new URLSearchParams(window.location.search);
    Object.keys(filters).forEach(function(filterType) {
      params.delete(filterType);
      if (filters[filterType].size)
        params.append(filterType, Array.from(filters[filterType]));
    });
    var newRelativePathQuery = window.location.pathname + (params.toString() ? '?' : '') + params.toString();
    if (newRelativePathQuery != window.location.pathname + window.location.search)
      history.pushState(null, '', newRelativePathQuery);
  }

  function titlesMatch(title1, title2) {
    return title1.match(/<a.*>(.*)<\/a>/)?.[1] == title2.match(/<a.*>(.*)<\/a>/)?.[1]
  }

  function updateFilterOptionCounts() {
    Object.keys(filterOptions).forEach(function(optionFilterType) {
      filterOptions[optionFilterType].forEach(function(option) {
        const filterOptionCount = $(`.filter-${slugify(optionFilterType)} li[data-option="${option}"] .filter-option-count`);

        // If the filter is already set, just remove the count
        if (filters[optionFilterType].has(option)) {
          filterOptionCount.text('');
          return;
        }

        // When there are no options set for a filter, adding an option *reduces* options, which is easy to calculate and is the
        // first option here.
        if (filters[optionFilterType].size == 0) {
          const remainingItems = papersList.matchingItems.filter(item => { return item.values()[optionFilterType].includes(option) })
          filterOptionCount.text('(' + remainingItems.length + ')');
        } else {
          // When there are options set for a filter, adding an option *increases* options, which we calculate here
          const unmatchedItems = papers.filter(paper => !papersList.matchingItems.some(item => titlesMatch(paper.Title, item.values().Title)))
          const newFilteredItems = unmatchedItems.filter(item => { return item[optionFilterType].includes(option) })

          // now apply the other filters
          const remainingFilteredItems = newFilteredItems.filter(item => {
            return Object.keys(filters).every(function(filterType) {
              if (filters[filterType].size == 0) return true
              if (filterType == optionFilterType) return true

              return item[filterType].some(item => filters[filterType].has(item))
            });
          });

          // now apply the search
          const searchTerm = $('input.search').val();
          // iterate through every field on each item and see if it matches the search term
          const remainingItems = remainingFilteredItems.filter(item => {
            return Object.keys(item).some(field => {
              return item[field].toString().toLowerCase().includes(searchTerm.toLowerCase())
            })
          })

          filterOptionCount.text(`(${remainingItems.length})`);
        }
        
      });
    });
  }

  function updateList(){
    updateFilters();
    papersList.update();
    updateFilterOptionCounts();
    updateShownFilters();
    updateFilterTitleCount();
    updateQueryParams();
  }

  function linkify(s, linkText) {
    if (!s) return '';
    return `<a href="${s}" target="_top">${linkText || s}</a>`
  }

  function slugify(s) {
    return s.toLowerCase().replace(' ', '_').replace(/\s/g, '_').replace(/[^a-z0-9-_]/g, '');
  }

  document.addEventListener("DOMContentLoaded", function() {
    // Clicks on the dropdown title show/hide the dropdown
    $(".dropdown-title-box").on("click", function(e) {
      e.stopPropagation();
      var target = $(this).data("target");
      if ($("#" + target).hasClass('active')) {
        $('.filter-dropdown').removeClass('active');
      } else {
        $('.filter-dropdown').removeClass('active');
        $("#" + target).addClass("active");
      }
    });

    // Clicks outside a dropdown close it
    $('body').on('click', function(e) {
      if ($(e.target).closest('.filter-dropdown').length) return;

      $('.filter-dropdown').removeClass('active');
    });

    // Clicks on the filter items remove them
    $('body').on('click', '.filter-item', function(e) {
      var filter = $(e.target).closest('.filter-item').text();
      var filterType = $(e.target).closest('.filter-item').data('filter-type');
      $('input[name="option-' + slugify(filterType) + '-' + filter + '"]').prop('checked', false);
      filters[filterType].delete(filter);
      updateList();
    });

    // Clicks on the list items toggle them open/closed
    $('body').on('click', '.paper-item', function(e) {
      if ($(e.target).closest('a').length) return;

      e.stopPropagation();
      $(e.target).closest(".paper-item").toggleClass("active");
      $(e.target).closest(".paper-item").find('.detail').slideToggle(200);
    });
  });
</script>
